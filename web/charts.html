<!DOCTYPE html>
<html>
  <head>
    <title>IRM</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <script>
      function chart(data, datelabels, minilabel, chartID) {

        const ctx = document.getElementById(chartID).getContext('2d');

        // All the charts have the same color schemes.
        const backgroundColor = [
          'rgba(255, 99, 132, 0.2)',
          'rgba(54, 162, 235, 0.2)',
          'rgba(255, 206, 86, 0.2)',
          'rgba(75, 192, 192, 0.2)',
          'rgba(153, 102, 255, 0.2)',
          'rgba(255, 159, 64, 0.2)'
        ];
        const borderColor = [
          'rgba(255, 99, 132, 1)',
          'rgba(54, 162, 235, 1)',
          'rgba(255, 206, 86, 1)',
          'rgba(75, 192, 192, 1)',
          'rgba(153, 102, 255, 1)',
          'rgba(255, 159, 64, 1)'
        ];
        const options = {
          scales: {
            y: {
              beginAtZero: true
            }
          }
        };

        if (chartID == "Chart1") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "HTTP/1.1",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "HTTP/2",
                  data: data[1],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "HTTP/3",
                  data: data[2],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                }
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
              min: 0,
            max: 100,
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        } else if (chartID == "Chart2") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "TLSv1.0",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "TLSv1.1",
                  data: data[1],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "TLSv1.2",
                  data: data[2],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "TLSv1.3",
                  data: data[3],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                }
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        }else if (chartID == "Chart3") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "Cloudflare Total",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Cloudflare ipv4",
                  data: data[1],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Cloudflare ipv6",
                  data: data[2],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        }else if (chartID == "Chart4") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "Fastly Total",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Fastly ipv4",
                  data: data[1],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Fastly ipv6",
                  data: data[2],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        }else if (chartID == "Chart5") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "Dualstack",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Ipv4",
                  data: data[1],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Ipv6",
                  data: data[2],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        }else if (chartID == "Chart6") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "DNS ANY",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                }, 
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        }else if (chartID == "Chart7") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "Stackpath enabled",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
        scales: {
            y: {
                ticks: {
                    callback: function(value, index, values) {
                        return value + '%';
                    }
                }
            }
        }
    }
          });
        } 
        else if (chartID == "Chart8") {
          const myChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: datelabels,
              datasets: [
                {
                  label: "Digicert Certificate Usage",
                  data: data[0],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                }, 
                {
                  label: "Comodo Certificate Usage",
                  data: data[1],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
                {
                  label: "Let's Encrypt Usage",
                  data: data[2],
                  backgroundColor: backgroundColor,
                  borderColor: borderColor,
                  borderWidth: 1
                },
              ]
            },
            options: {
              plugins: {
                tooltip: {
                  mode: 'index',
                  intersect: false
                }
              },
              
            scales: {
                y: {
                    ticks: {
                        callback: function(value, index, values) {
                            return value + '%';
                        }
                    }
                }
            }, 
          }
        });
      }
    }

      async function fetchDataHTTP() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv')

        const data = await response.text()
        const vals = data.split('\n')
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            timestapmp : row[0],
            http2 : row[2],
            http11 : row[3],
            http3 : row[4],
          });
        }

        const timelabel = [];
        const http = [[],[],[],[]];
        let i = 0;
        while (jsondata[i] != undefined) {
          timelabel.push(jsondata[i].timestapmp);
          http[0].push(jsondata[i].http11.replace("%",""));
          http[1].push(jsondata[i].http2.replace("%",""));
          http[2].push(jsondata[i].http3.replace("%",""));
          i++;
        }

        chart(http, timelabel, "% of HTTP supported Websites", "Chart1");
      }

      async function fetchDataTLS() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            tls10 : row[7],
            tls11 : row[8],
            tls12 : row[9],
            tls13 : row[10],
          });
        }

        const tls = [[],[],[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          tls[0].push(jsondata[i].tls10.replace("%",""));
          tls[1].push(jsondata[i].tls11.replace("%",""));
          tls[2].push(jsondata[i].tls12.replace("%",""));
          tls[3].push(jsondata[i].tls13.replace("%",""));
          i++;
        }

        chart(tls, time, "% of TLS Websites", "Chart2");
      }
      async function fetchdataCloudflare() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            cloud : row[11],
            cloudipv4 : row[12],
            cloudipv6 : row[13],
          });
        }

        const cloud = [[],[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          cloud[0].push(jsondata[i].cloud.replace("%",""));
          cloud[1].push(jsondata[i].cloudipv4.replace("%",""));
          cloud[2].push(jsondata[i].cloudipv6.replace("%",""));
          i++;
        }

        chart(cloud, time, "% of Cloudflare support", "Chart3");
      }

      async function fetchdataFastly() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            fastly : row[14],
            fastlyipv4 : row[15],
            fastlyipv6 : row[16],
          });
        }

        const fastly = [[],[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          fastly[0].push(jsondata[i].fastly.replace("%",""));
          fastly[1].push(jsondata[i].fastlyipv4.replace("%",""));
          fastly[2].push(jsondata[i].fastlyipv6.replace("%",""));
          i++;
        }

        chart(fastly, time, "% of Cloudflare support", "Chart4");
      }

      
      async function totalipv() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            ipvtotal : row[18],
            ipv4 : row[19],
            ipv6 : row[20],
          });
        }

        const ipv = [[],[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          ipv[0].push(jsondata[i].ipvtotal.replace("%",""));
          ipv[1].push(jsondata[i].ipv4.replace("%",""));
          ipv[2].push(jsondata[i].ipv6.replace("%",""));
          i++;

        }
        chart(ipv, time, "% of IPV support", "Chart5");
      }
      async function dnsany() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            dnsany : row[21]
          });
        }

        const dnsany = [[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          dnsany[0].push(jsondata[i].dnsany.replace("%",""));
          i++;

        }
        chart(dnsany, time, "% of DNS ANY support", "Chart6");
      }

      async function totalstackpath() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            stackpath: row[17],
          });
        }

        const stackpath = [[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          stackpath[0].push(jsondata[i].stackpath.replace("%",""));
       
          i++;

        }
        chart(stackpath, time, "% of Stackpath support", "Chart7");
      }

      async function sslcertificate() {
        const jsondata = [];
        const response = await fetch('https://raw.githubusercontent.com/derekargueta/irm-data/master/results.csv');

        const data = await response.text();
        const vals = data.split('\n');
        for (let i = 1; i < vals.length-1; i++) {
          const row = vals[i].split(',');
          jsondata.push({
            time: row[0],
            digicert: row[22],
            comodo: row[23],
            encrypt: row[24],
          });
        }

        const cert = [[],[],[]];
        const time = [];
        let i = 0;
        while (jsondata[i] != undefined) {
          time.push(jsondata[i].time);
          cert[0].push(jsondata[i].digicert.replace("%",""));
          cert[1].push(jsondata[i].comodo.replace("%",""));
          cert[2].push(jsondata[i].encrypt.replace("%",""));
          i++;

        }
        chart(cert, time, "% of Stackpath support", "Chart8");
      }

      fetchDataTLS();
      fetchDataHTTP();
      fetchdataCloudflare();
      fetchdataFastly();
      totalipv();
      dnsany();
      totalstackpath();
      sslcertificate();
    </script>
    <style>
     
    </style>
  </head>
  <body>
    <div class="info-container">
      <h1 class="text-format">The Internet Measurement Research Project</h1>
      <p class="text-format">This is a project that aims to monitor the deployment of various protocols and web technologies to gauge the general status of the internet. We scan a list of domains and run probes against each domain. A probe is simply a TCP connection that records what versions of a protocol worked. This provides a rough estimation of the Internet. In the future, we will develop techniques for discovering new domains, and pruning domains that are no longer valid to keep the data set as accurate as possible. All of our source code is at <a href="https://github.com/derekargueta/irm" target="_blank">github.com/derekargueta/irm</a>. Inspiration for this project was drawn from HTTP Archive's <a href="https://httparchive.org/reports/state-of-the-web" target="_blank">State of the Web</a>, <a href="https://observatory.mozilla.org/" target="_blank">Mozilla Observatory</a>, and BYU's <a href="https://imaal.byu.edu/" target="_blank">Internet Measurement and Anti-Abuse Lab</a>.</p>
    </div>
      <h2 class="text-format">Data</h2>
   
      <div class="">
        <h3 class="text-format">Supported HTTP Versions</h3>
        <p class="text-format">Based on our sample set, this is the percent of domains probed that support HTTP/1.1 vs HTTP/2 vs HTTP/3</p>
      </div>

      <div class="charts">
        <canvas id="Chart1"></canvas>
      </div>
 

      <div class="">
        <h3 class="text-format">Supported TLS Versions</h3>
        <p class="text-format"> Based on our sample set, this is the percent of domains probed that support the various versions of TLS.</p>
      </div>

      <div class="charts">
        <canvas id="Chart2"></canvas>
      </div>
  
      <div class="">
        <h3 class="text-format">Supported Cloudflare Versions</h3>
        <p class="text-format">Based on our sample set, this is the percent of domains probed that support Cloudflare</p>
      </div>
      <div class="charts">
        <canvas id="Chart3"></canvas>
      </div>
      
       <div class="">
        <h3 class="text-format">Supported Fastlyprobe Versions</h3>
        <p class="text-format">Based on our sample set, this is the percent of domains probed that supports Fastly</p>
      </div>
      <div class="charts">
        <canvas id="Chart4"></canvas>
      </div>

      <div class="">
        <h3 class="text-format">Supported IPV Versions</h3>
        <p class="text-format">Based on our sample set, this is the percent of domains probed that support IPV4, IPV6, or both (dualstack)</p>
      </div>
      <div class="charts">
        <canvas id="Chart5"></canvas>
      </div>

      <div class="">
        <h3 class="text-format">Supported of DNS ANY </h3>
        <p class="text-format">Based on our sample set, this is the percent of domains queried through DNS ANY</p>
      </div>
      <div class="charts">
        <canvas id="Chart6"></canvas>
      </div>
      <div class="">
        <h3 class="text-format">Supported of Stackpath</h3>
        <p class="text-format">Based on our sample set, this is the percent of Stackpath enabled websites</p>
      </div>
      <div class="charts">
        <canvas id="Chart7"></canvas>
      </div>
      <div class="">
        <h3 class="text-format">Supported of SSL Certificates</h3>
        <p class="text-format">Based on our sample set, this is the percent of Certificate usage</p>
      </div>
      <div class="charts">
        <canvas id="Chart8"></canvas>
      </div>  
     


    <!-- <div class="info-container">
      <h2>Who</h2>
      <div class="profile" style="float: left">
        <h3>Derek Argueta - Researcher</h3>
        <p>Derek is a senior software engineer at Tesla where he works on cloud-based systems that enable remote vehicle connectivity features such as OTA updates and command execution. His interests lay at the intersection of networking and distributed systems. He's also an on/off contributor to the <a href="https://www.envoyproxy.io/" target="_blank">Envoy proxy project</a> and is diving into <a href="https://tinygo.org/" target="_blank">TinyGo</a> with <a href="https://www.espressif.com/en/products/socs/esp32" target="_blank">Espressif ESP32 microcontrollers</a>.</p>
      </div>
      <div class="profile" style="float: right">
        <h3>Henry Palma - Research Assistant</h3>
        <p>Henry is a sophmore at the University of Houston in Houston, Texas studying Computer Science. He has created IOS apps aligned with his interests such as the Arduino Pocket Guide and his own personal beat machine.</p>
      </div>
    </div> -->

  
  </body>
<!-- make chart smaller -->
<!-- make y axis 0-100 / consistent -->
</html>

<!-- 
  0. time stamp 	
  1. Domain tested 	
  2. percent http2 	
  3. percent http1.1 	
  4. percent http3 	
  5. percent connection error 	
  6. time elapsed 	
  7. tls1.0 enabled 	
  8. tls1.1 enabled 	
  9. tls1.2 enabled 	
  10. tls1.3 enabled 	
  11. cloudflare 	
  12. cloudflare ipv4 	
  13. cloudflare ipv6 	
  14. fastlyprobe 	
  15. fastlyprobe ipv4 	
  16. fastlyprobe ipv6 	
  17. Stackpath enabled 	
  18. dualstack 	
  19. total ipv4 	
  20. total ipv6 	
  21. dns_any enabled 	
  22. Digicert Certificate Usage 	
  23. Comodo Certificate Usage 	
  24. Let's Encrypt Usage 
-->